heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Create the heatmap with y-axis labels on the left side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the left side (closer to the heatmap)
mtext("User Segments", side = 2, line = 0.3)
# Get the first two principal components
pca_components_subset <- pca_result$rotation[, 1:2]  # Select first two columns
# Project medoids back to original space using only the first two components
projected_medoids <- pca_components_subset %*% t(pam.res$medoids)  # Matrix multiplication
# Optional: Convert projected medoids to a data frame (if needed)
projected_medoids_df <- data.frame(t(projected_medoids))  # Transpose and convert to data frame
# Now, projected_medoids_df contains the projected medoids using only the first two principal components.
print(projected_medoids_df)
# Remove outliers from the original data
cleaned_data <- new_data[!rowSums(outliers) > 0, ]
# Scale the cleaned data
scaled_data <- scale(cleaned_data)
#elbow method
wcss <- numeric(length = 5)  # Initialize vector to store WCSS values
for (k in 1:5) {
kmeans_result <- kmeans(scaled_data, centers = k)
wcss[k] <- kmeans_result$tot.withinss
}
elbow_plot <- data.frame(K = 1:5, WCSS = wcss)
# Plot the elbow curve with labels
ggplot(elbow_plot, aes(x = K, y = WCSS, label = sprintf("(K=%d, WCSS=%.2f)", K, WCSS))) +
geom_line() +
geom_point() +
geom_text(nudge_x = 0.5, nudge_y = -500, size = 3) +  # Adjust position and size of labels
labs(x = "Number of Clusters (K)", y = "Within-Cluster Sum of Squares (WCSS)",
title = "Elbow Method for Optimal K")
# Remove outliers from the original data
cleaned_data <- new_data[!rowSums(outliers) > 0, ]
# Scale the cleaned data
scaled_data <- scale(cleaned_data)
head(scaled_data)
# Apply PCA
pca_result <- prcomp(scaled_data, scale. = TRUE)
# Plot the scree plot to visualize the explained variance by each principal component
fviz_eig(pca_result)
#Determine the number of principal components to retain (e.g., based on the elbow method)
#From the scree plot, select the number of components that explain a significant portion of the variance
#Select the number of principal components to retain
num_components <- 2
fviz_cluster(pam.res, pca_data,
ellipse.type = "convex",
geom=c("point"),
palette = "jco",
ggtheme = theme_classic()) #you can change the color palette and theme to your preferences
# Obtain cluster assignments
cluster_assignments <- pam.res$cluster
# Calculate silhouette scores
silhouette_scores <- silhouette(cluster_assignments, dist(pca_data))
# Mean silhouette score
mean_silhouette <- mean(silhouette_scores[, "sil_width"])
# Print mean silhouette score
print(paste("Mean silhouette score:", round(mean_silhouette, 2)))
# Plot silhouette plot
fviz_silhouette(silhouette_scores,
palette = "jco",
ggtheme = theme_classic())
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("blue", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("blue", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
#DUNN TEST
# Compute pairwise-distance matrices for PCA clustering
pca_stats <- dist(pca_data, method = "euclidean")
# Statistics for PCA clustering
pca_stats_result <- cluster.stats(pca_stats, pam.res$cluster)  # assuming 'pam.res' contains the clustering result from PCA
pca_stats_result  # Print the Dunn index and other statistics
#CLUSTER DESCRIPTION ANALYSIS OF PCs AND CLUSTER STATS
#Calculate statistics for each cluster, such as the mean, standard deviation, minimum, maximum
# Group the data by cluster
cluster_groups <- split(pca_data, pca_data$cluster)
# Calculate cluster statistics
cluster_stats <- lapply(cluster_groups, function(cluster) {
apply(cluster[, -which(names(cluster) == "cluster")], 2, summary)  # Exclude the "cluster" column
})
# Print cluster statistics
print(cluster_stats)
#HEATMAP SHOWING CLUSTER SEPARATION
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Check the dimensions of heatmap_data
dim(heatmap_data)
# Check the length of col_names
length(col_names)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Reassign column names to the heatmap data
colnames(heatmap_data) <- col_names
# Check the dimensions of heatmap_data
dim(heatmap_data)
# Check the length of col_names
length(col_names)
setwd("C:/Users/teres/Desktop/Machine Learning/Machine learning coursework")
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Reassign column names to the heatmap data
colnames(heatmap_data) <- col_names
# Read CSV file
data <- read.csv("Data_DMML.csv")
library(ggplot2)
library(tidyverse)
library(dplyr)
library(forcats)
library(cluster)
library(fpc)
library(dbscan)
library(stats)
library(factoextra)
library(tidytext)
library(stringr)
library(RColorBrewer)
library(ggpattern)
library(forcats)
library(viridis)
library(hrbrthemes)
library(ggimage)
library(rgl)
library(png)
library(ggdist)
library(gridExtra)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
# View the structure of the data
str(data)
# View the first few rows of the data
head(data)
# Specify the columns to remove
columns_to_remove <- c("ID")
# Remove the specified columns from the dataset
new_data <- data[, !names(data) %in% columns_to_remove]
#outlier removal
# Check for outliers in the entire dataset
outliers <- sapply(new_data, function(x) {
qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
H <- 1.5 * IQR(x, na.rm = TRUE)
x < (qnt[1] - H) | x > (qnt[2] + H)
})
# Print rows containing outliers
print(new_data[rowSums(outliers) > 0, ])
#ELBOW METHOD
# Remove outliers from the original data
cleaned_data <- new_data[!rowSums(outliers) > 0, ]
# Scale the cleaned data
scaled_data <- scale(cleaned_data)
#elbow method
wcss <- numeric(length = 5)  # Initialize vector to store WCSS values
for (k in 1:5) {
kmeans_result <- kmeans(scaled_data, centers = k)
wcss[k] <- kmeans_result$tot.withinss
}
elbow_plot <- data.frame(K = 1:5, WCSS = wcss)
# Plot the elbow curve with labels
ggplot(elbow_plot, aes(x = K, y = WCSS, label = sprintf("(K=%d, WCSS=%.2f)", K, WCSS))) +
geom_line() +
geom_point() +
geom_text(nudge_x = 0.5, nudge_y = -500, size = 3) +  # Adjust position and size of labels
labs(x = "Number of Clusters (K)", y = "Within-Cluster Sum of Squares (WCSS)",
title = "Elbow Method for Optimal K")
#PAM CLUSTERING WITH PCA
# Remove outliers from the original data
cleaned_data <- new_data[!rowSums(outliers) > 0, ]
# Scale the cleaned data
scaled_data <- scale(cleaned_data)
head(scaled_data)
# Apply PCA
pca_result <- prcomp(scaled_data, scale. = TRUE)
# Plot the scree plot to visualize the explained variance by each principal component
fviz_eig(pca_result)
#Determine the number of principal components to retain (e.g., based on the elbow method)
#From the scree plot, select the number of components that explain a significant portion of the variance
#Select the number of principal components to retain
num_components <- 2  # Example: Retain the first 2 principal components
#Extract the selected principal components
pca_data <- as.data.frame(predict(pca_result, newdata = scaled_data)[, 1:num_components])
pam.res <- pam(pca_data, 3)
print(pam.res)
pca_data <- cbind(pca_data, cluster = pam.res$cluster)
head(pca_data)
print(pca_data)
pam.res$medoids
fviz_cluster(pam.res, pca_data,
ellipse.type = "convex",
geom=c("point"),
palette = "jco",
ggtheme = theme_classic()) #you can change the color palette and theme to your preferences
#TABLES
#1. USED AS FIRST CLUSTER DESCRIPTION ANALYSIS
# only PC1 and PC2 are projected back to original space as only
# those two were used for clustering based on scree plot
#table project the medoids identified in PCA space back to the original data space
# Get the first two principal components
pca_components_subset <- pca_result$rotation[, 1:2]  # Select first two columns
# Project medoids back to original space using only the first two components
projected_medoids <- pca_components_subset %*% t(pam.res$medoids)  # Matrix multiplication
# Optional: Convert projected medoids to a data frame (if needed)
projected_medoids_df <- data.frame(t(projected_medoids))  # Transpose and convert to data frame
# Now, projected_medoids_df contains the projected medoids using only the first two principal components.
print(projected_medoids_df)
#table LOADINGS
#2. USED AS SECOND CLUSTER DESCRIPTION ANALYSIS
# Extract the loadings from the PCA result
loadings <- pca_result$rotation
# Create a dataframe with loadings for each principal component
loadings_df <- as.data.frame(loadings)
# Add column names
colnames(loadings_df) <- paste("PC", 1:ncol(loadings_df))
# Print the loadings dataframe
print(loadings_df)
#EVALUATION SILHOUETTE ANALYSIS
# Obtain cluster assignments
cluster_assignments <- pam.res$cluster
# Calculate silhouette scores
silhouette_scores <- silhouette(cluster_assignments, dist(pca_data))
# Mean silhouette score
mean_silhouette <- mean(silhouette_scores[, "sil_width"])
# Print mean silhouette score
print(paste("Mean silhouette score:", round(mean_silhouette, 2)))
# Plot silhouette plot
fviz_silhouette(silhouette_scores,
palette = "jco",
ggtheme = theme_classic())
#PRINT NEGATIVE VALUES
# Create a data frame to store cluster assignments and silhouette scores
cluster_silhouette_df <- data.frame(
Cluster = cluster_assignments,
Silhouette_Score = silhouette_scores[, "sil_width"]
)
# Add a column indicating whether the silhouette score is negative
cluster_silhouette_df$Negative_Silhouette <- cluster_silhouette_df$Silhouette_Score < 0
# Filter out only the rows with negative silhouette scores
negative_silhouette_df <- cluster_silhouette_df[cluster_silhouette_df$Negative_Silhouette == TRUE, ]
# Print the table
print("Cluster Assignments with Negative Silhouette Scores:")
print(negative_silhouette_df)
#DUNN TEST
# Compute pairwise-distance matrices for PCA clustering
pca_stats <- dist(pca_data, method = "euclidean")
# Statistics for PCA clustering
pca_stats_result <- cluster.stats(pca_stats, pam.res$cluster)  # assuming 'pam.res' contains the clustering result from PCA
pca_stats_result  # Print the Dunn index and other statistics
#CLUSTER DESCRIPTION ANALYSIS OF PCs AND CLUSTER STATS
#Calculate statistics for each cluster, such as the mean, standard deviation, minimum, maximum
# Group the data by cluster
cluster_groups <- split(pca_data, pca_data$cluster)
# Calculate cluster statistics
cluster_stats <- lapply(cluster_groups, function(cluster) {
apply(cluster[, -which(names(cluster) == "cluster")], 2, summary)  # Exclude the "cluster" column
})
# Print cluster statistics
print(cluster_stats)
#HEATMAP SHOWING CLUSTER SEPARATION
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Reassign column names to the heatmap data
colnames(heatmap_data) <- col_names
colnames(heatmap_data) <- col_names
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
dim(heatmap_data)
length(col_names)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the left side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the left side (closer to the heatmap)
mtext("User Segments", side = 2, line = 0.3)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the left side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the left side (closer to the heatmap)
mtext(c("Cluster 1", "Cluster 2", "Cluster 3"), side = 2, line = c(0.2, 0.5, 0.8))
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the left side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the left side (closer to the heatmap)
mtext("User Segments", side = 2, line = 0.3)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the right side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the right side (closer to the heatmap)
mtext(c("Cluster 1", "Cluster 2", "Cluster 3"), side = 4, line = c(0.2, 0.5, 0.8))
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the right side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the right side (closer to the heatmap)
axis(4, at = seq(1, 3), labels = c("Cluster 1", "Cluster 2", "Cluster 3"), las = 1)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
# Create the heatmap with y-axis labels on the left side
heatmap(heatmap_data,
Colv = NA, Rowv = NA,
col = colors,
main = "Engagement Heatmap",
xlab = "Metrics",
ylab = "",
cex.axis = 0.8,  # Adjusts the size of the axis labels
las = 1,         # Makes the labels horizontal
margins = c(10, 8))  # Adjusts the margins to move y-axis labels to the left
# Add the y-axis label on the left side (closer to the heatmap)
mtext("User Segments", side = 2, line = 0.3)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Load the gplots package
library(gplots)
# Load the gplots package
library(gplots)
install.packages("gplots")
# Load the gplots package
library(gplots)
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Convert the dataframe to a matrix
heatmap_data <- as.matrix(projected_medoids_df)
# Define the colors for the heatmap
colors <- colorRampPalette(c("yellow", "red"))(100)
# Set the column names
col_names <- c("Cluster 1", "Cluster 2", "Cluster 3")
colnames(heatmap_data) <- col_names
# Load necessary libraries
library(pROC)
# Assuming 'actual' contains the true labels and 'predictions' contains the predicted labels
actual <- as.factor(actual)
predictions <- as.factor(predictions)
# Calculate weighted F1-score
weighted_f1 <- function(Reference, Test) {
f1_scores <- sapply(levels(Reference), function(level) {
tp <- sum(Test == level & Reference == level)
fp <- sum(Test == level & Reference != level)
fn <- sum(Test != level & Reference == level)
precision <- tp / (tp + fp)
recall <- tp / (tp + fn)
f1 <- 2 * (precision * recall) / (precision + recall)
prevalence <- mean(Reference == level)
weighted_f1 <- prevalence * f1
return(weighted_f1)
})
return(sum(f1_scores))
}
weighted_f1_score <- weighted_f1(actual, predictions)
print(paste("Weighted F1-score:", weighted_f1_score))
# Calculate G-mean
g_mean <- sqrt(prop.table(table(actual, predictions), margin = 1)[1, ] %*% prop.table(table(actual, predictions), margin = 2)[, 1])
print(paste("G-mean:", g_mean))
# Create ROC curve object
roc_obj <- roc(ifelse(predictions == "1", 1, 0), ifelse(actual == "1", 1, 0))
# Calculate AUC-ROC
auc_roc <- auc(roc_obj)
print(paste("AUC-ROC:", auc_roc))
# Plot AUC-ROC curve
plot(roc_obj, main = "ROC Curve", col = "blue")
legend("bottomright", legend = paste("AUC = ", round(auc_roc, 2)), col = "blue", lty = 1, cex = 0.8)
# Get the first two principal components
pca_components_subset <- pca_result$rotation[, 1:2]  # Select first two columns
# Project medoids back to original space using only the first two components
projected_medoids <- pca_components_subset %*% t(pam.res$medoids)  # Matrix multiplication
# Optional: Convert projected medoids to a data frame (if needed)
projected_medoids_df <- data.frame(t(projected_medoids))  # Transpose and convert to data frame
# Now, projected_medoids_df contains the projected medoids using only the first two principal components.
print(projected_medoids_df)
# View the first few rows of the data
head(data)
